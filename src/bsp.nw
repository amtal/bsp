\documentclass{article}
\usepackage{noweb}
\pagestyle{noweb}
\usepackage{graphicx}

\title{BSP Trees in Erlang}
\author{Alex Kropivny}
\begin{document}
\maketitle

\tableofcontents


\noweboptions{smallcode}

\section{Introduction}

There is an age old problem in immutable languages: how do I mutate a piece of a huge chunk of data, without copying the whole thing?

The answer is trees. The problem came up again recently, in an Erlang IRC channel, with respect to a Minecraft server. The game stores a massive amount of often-mutated data in a 3D grid. It highlighted a potential gap in existing libraries: multiple solutions were proposed, but all felt a little off.

A new data structure is required. It must support:

\begin{itemize}
\item Integer indexes in multiple dimensions, for bulk XYZ storage.
\item Efficient storage of localy repetitive data, which there'll be lots of.
\item Regular simple bulk queries, for dumping data to newly connected clients.
\item Occasional point mutation, for live world editing.
\item Infrequent flexible queries that filter and transform the data into simpler forms, for building fundamental pathing, physics, and lighting data structures.
\end{itemize}

I'd also like it to be infinite, and support declarative, comonad-like transformations... But without laziness, that abstraction is probably best left to a higher level.

The structure I'm implementing is a trivial binary space partitioned tree constructed from list cons cells. It is efficient to update, simple to implement, and has some very interesting properties for integer indexing and transformations.

The library is implemented in Lisp Flavored Erlang for simplicity and development speed. It is documented via Knuth's literate programming to clarify and explain some of the algorithms and design choices.

\section{Files}

Brief usage documentation is in a Github README, with detailed documentation generated into a PDF.

<<../README.md>>=
<<Intro docs>>

Building
========
<<Building docs>>

Viewing
=======
<<Viewing docs>>

Querying
========
<<Querying docs>>

Transforming
============
<<Transforming docs>>
@

All code is one module.

<<bsp.lfe>>=
;;; Code automatically generated from bsp.nw literate program. Go read the PDF
;;; generated alongside, instead of this commentless soup. The following isn't
;;; meant for human consumption!
(include-lib "lfe_utils/include/all.lfe")
(defmodule bsp
  (using lists)
  (export <<Exports>>))

;; Vector manipulation:
<<Vectors>>

;; General utilities:
<<Utilities>>

;; BSP tree manipulation:
<<Functions>>
@

\section{Vectors}

We need a vector data type. Since there are no Erlang vector libraries that I'm aware of, I'm making my own. It conforms to good Erlang practice, and will be compatible with any good 3rd party code that pops up.

The BSP trees we're concerned with are trivial ones, where the volume being partitioned is always split exactly in half. Their structures have a nifty relation to the bits in the integer index of the volume being partitioned, which we'll take advantage of.

It's worth underlining that Erlang integers have no upper bound, and can easily be converted to binaries and back. They are a very flexible data type.

<<Intro docs>>=
Tagged tuples of integers are used as coordinate and size vectors. Tag and size
are up to you: {vec3,0,1,0} and {addr,192,168,1,1} are valid 3 and 4 dimensional
vectors.  Each tree should only contain one type of vector. Mixing things like
{cartesian,0,1} and {polar,1,90} won't work.

```erlang
-spec vector(N) :: {term(),integer(),...} when N==size(Tuple)-1.
```
@

Starting with basic helper and sanitization functions.

<<Utilities>>=
(defn list->tup [l] (list_to_tuple l))
(defn tup->list [t] (tuple_to_list t))
@

<<Vectors>>=
; sanitize input
(defn vector? 
  [v] (when (is_tuple v))
    (lists:all (fun is_integer 1) (vec-contents v)))
  [_] 'false)

; get list of integers
(defn vec-contents [v] 
  (tl (tup->list v)))

(defn make-vec [tag contents]
  (list->tup (cons tag contents)))
@

Dereferencing one split of a BSP tree is a rotation. We'll end up iterating over the vector components by repeatedly rotating the vector, and looking at only the first component.

<<Vectors>>=
; make first element last, shift rest to take its place
(defn vec-rot [v] 
  (in (list->tup (cons tag xs'))
   [xs' (++ most (list last))
    (last . most) xs
    (tag . xs) (tup->list v)]))

; same, but overwrite first element
(defn vec-rot-with [x v]
  (in (list->tup (cons tag xs')
   [xs' (++ (tl xs) (list x))
    (tag . xs) (tup->list v)])))

; first vector element ('x')
(defn 1st-el [v] (element 2 v))
@

Alternatively, an index into the vector could be used.

<<Vectors>>=
(defn vec-size [v] (- (size v) 1))

; proper zero-based indexing
(defn vec-nth [n v] (element (+ n 2) v))

; overflow indexes that get too large
(defn vec-index [n v]
  (let (if (< 0 n') n' (+ size n'))
   [n' (rem n size)
    size (vec-size v)]))
@

Because trivial splits always cut volumes in exactly half, our BSP tree dimensions are restricted to powers of two.

<<Utilities>>=
; test for power of two
(defn 2^n?
  [n] (when (=< n #xff)) (2^n-byte? n)
  [n] (andalso (== 0 (band #xff n)) 
               (2^n? (bsr n 8))))

(defn 2^n-byte?
  [1]  'true [2]  'true [4]  'true [8]   'true
  [16] 'true [32] 'true [64] 'true [128] 'true
  [_] 'false)
@

<<Vectors>>=
(defn 2^n-vec? [v]
  (lists:all (fun 2^n? 1) (vec-contents v)))
@

Finally, the minimum usual operations. The size-apathetic arithmetic ones are slow, but can be optimized later as needed. (When there are benchmarks proving they're worth optimizing.) Pattern matching common (2, 3, 4d vectors) cases should be enough. Using macros to compile matches for arbitrary sizes would be fun, but probably unnecessary.

<<Vectors>>=
; construct a null vector of the same type as another
(defn null-vec [v] 
  (: erlang make_tuple (vec-size v) 0 
                       (list (tuple 1 (element 1 v))))

(defn unit-hypercube? [v]
  (== v (: erlang make_tuple (vec-size v) 1
                             (list (tuple 1 (element 1 v))))))

(defn :+ (va vb) 
  (in (make-vec tag els)
   [tag (element 1 va)
    els (lists:zipwith (fun erlang + 2) 
                       (vec-contents va) 
                       (vec-contents vb))]))
@


\section{Foundations}

<<Intro docs>>=
Trees are indexed by an N-dimensional vector, and can contain anything.

```erlang
-type tree(N,A)::{bsp,term(),term()} when N::integer(), A::any().
```
@

<<Exports>>=
(is_tree 1)
@

<<Functions>>=
(defn is_tree 
  [(tuple 'bsp size _data)] (2^n-vec? size)
  [_] 'false)
@

\subsection{Construction}

Let's start by constructing a tree. The minimal tree is a single homogenous volume, with power-of-two dimensions. Trees with identical dimensions are merged together to form larger trees, with merges happening sequentially through all the dimensions of the tree.

Most initial data representations are flat, and don't group together similar contents. Trees do: when constructing a tree out of flat data, we need to do lots of comparisons between branches, and merge branches into a single volume if they're both minimal and identical.

Since there are many flat data types, we'll make the constructor a higher order function. We recursively subdivide the tree into smaller ones, until they're 1x1x1 in size. Then we use the lookup function to find the value of the volume there, and move up the stack, doing comparisons and merging as we go.

<<Exports>>=
(new 2)
@

<<Building docs>>=
Ideal constructor from flat data (binaries, arrays) accessible via vector lookups.

```erlang
-spec new(Size::vector(N), Lookup::fun(vector(N))->A) -> tree(N,A).
```
@

<<Utilities>>=
(defmacro :bsp ([size data] `(tuple 'bsp ,size ,data)))
@

<<Functions>>=
(defn new [size lup] 
  (if (2^n-vec? size)
    (:bsp size (build-new size (null-vec size) lup))
    (error 'badarg (list size lup))))
; where
  (defn build-new [size pos lup]
    (if (unit-hypercube? size)
      ; 1x1x1 sizes can be looked up
      (let [(volume (funcall lup pos))]
        (if (is_list volume)
          (error (tuple 'no_lists pos volume)))
        volume)
      ; larger ones must be split into two branches
      (in (if (minimal-identical-trees? left right)
            left ; merge
            (cons left right)) ; branch
       [left (build-new size' pos-left lup)
        right (build-new size' pos-right lup)
        ; cut the current axis in two
        size' (vec-rot-with (bsr (1st-el size) 1) size)
        ; position increased by an order of magnitude, with
        ; least significant bit indicating choice between
        ; left and right branches
        pos-left (vec-rot-with offset pos)
        pos-right (vec-rot-with (bor 1 offset) pos)
        offset (bsl (1st-el pos) 1)])))
  (defn minimal-identical-trees? [a b]
    (andalso (not (is_list a))
             (not (is_list b))
             (== a b)))
    
@

\subsection{Factoring}

Each cons cell represents a split on an axis. The axes are round robined. They are independent: so much so that an N dimensional tree can be factored into a J dimensional tree of K dimensional trees, where J+K=N.

<<Transforming docs>>=
Factor a tree into a lower-dimension tree of lower-dimension trees. Non-zero
vector elements mark dimensions to use in the top tree.

```erlang
-spec factor(Selector::vector(N), tree(N,A)) -> tree(J,tree(K,A)) where J+K=N.
```
@

<<Exports>>=
(factor 2)
@

The tree being factored to the top level, is a singleton. It branches along the dimensions specified in the selection vector, until there are no branches left. The branches are built by traversing the original tree top-down.

The contents of the branches, are trees. The inner trees are independent and varied, collected together in an accumulator as the top-level tree is built. The accumulator produces a different inner tree for each leaf of the top-level tree. 

The process can produce significant duplication between the inner trees. The inner trees no longer benefit from the structure of the top tree, thus leaking information.

<<Utilities>>=
(defn factor [axes (:bsp size data)]
  (in (:bsp outer-size (factor inner-size axes data acc))
   [(tuple outer-size inner-size) (partition-vec axes size)
    _ (if (/= (vec-size axes) (vec-size size))
        (error (tuple 'vector_dim_mismatch axes size)))]))
; where
  (defn factor [inner-size axes data inner] 'todo)
    
@

\section{Todo}

<<Viewing docs>>=
    todo
@
<<Querying docs>>=
    todo
@

\section{Index}
\nowebindex
\end{document}
