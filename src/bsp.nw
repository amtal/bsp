\documentclass{article}
\usepackage{noweb}
\pagestyle{noweb}
\usepackage{graphicx}

\title{BSP Trees in Erlang}
\author{Alex Kropivny}
\begin{document}
\maketitle

\tableofcontents


\noweboptions{smallcode}

\section{Introduction}

I need a data structure for storing dense but repetitive, multidimensional, integer-indexed data. It must efficiently support occasional mutations, and flexible bulk queries that filter down and transform the contents into smaller structures. I'd like it to be infinite and support declarative, comonad-like transformations... But will settle for something simple, and try to add that abstraction at a higher level.

The structure I've chosen to implement is a BSP tree made out of list cons cells. It is efficient to update, simple to implement, and has some interesting properties for transforming into simpler views.

The library is implemented in Lisp Flavored Erlang for simplicity and development speed. It is documented via literate programming for comprehension.

\section{Files}

All code is one module.

<<bsp.lfe>>=
;;; Code automatically generated from bsp.nw literate program. Go read the PDF
;;; generated alongside, instead of this commentless soup. The following isn't
;;; meant for human consumption!
(include-lib "lfe_utils/include/all.lfe")
(defmodule bsp
  (using lists)
  (export <<Exports>>))

;; Vector manipulation:
<<Vectors>>

;; General utilities:
<<Utilities>>

;; BSP tree manipulation:
<<Functions>>
@

Brief usage documentation is in a Github README, with detailed documentation generated into a PDF.

<<../README.md>>=
<<Intro docs>>

Building
========
<<Building docs>>

Viewing
=======
<<Viewing docs>>

Querying
========
<<Querying docs>>

Transforming
============
<<Transforming docs>>
@

\section{Vectors}

The following code is quite simple and dry, but necessary.

We need a vector data type. Since there are no Erlang vector libraries that I'm aware of, I'm making my own. It conforms to good Erlang practice, and will be compatible with any good 3rd party code that pops up.

The BSP trees we're concerned with are trivial ones, where the volume being partitioned is always split exactly in half. Their structures have a nifty relation to the bits in the integer index of the volume being partitioned, which we'll take advantage of.

It's worth underlining that Erlang integers have no upper bound, and can easily be converted to binaries and back. They are a very flexible data type.

<<Intro docs>>=
Tagged tuples of integers are used as coordinate and size vectors. Tag and size
are up to you: {vec3,0,1,0} and {addr,192,168,1,1} are valid 3 and 4 dimensional
vectors.  Each tree should only contain one type of vector. Mixing things like
{cartesian,0,1} and {polar,1,90} won't work.

```erlang
-spec vector(N) :: {term(),integer(),...} when N==size(Tuple)-1.
```
@

Starting with basic helper and sanitization functions.

<<Utilities>>=
(defn list->tup [l] (list_to_tuple l))
(defn tup->list [t] (tuple_to_list t))
@

<<Vectors>>=
; sanitize input
(defn vector? 
  [v] (when (is_tuple v))
    (lists:all (fun is_integer 1) (vec-contents v)))
  [_] 'false)

; get list of integers
(defn vec-contents [v] 
  (tl (tup->list v)))

(defn make-vec [tag contents]
  (list->tup (cons tag contents)))
@

Dereferencing one split of a BSP tree is a rotation. We'll end up iterating over the vector components by repeatedly rotating the vector, and looking at only the first component.

<<Vectors>>=
; make first element last, shift rest to take its place
(defn vec-rot [v] 
  (in (list->tup (cons tag xs'))
   [xs' (++ most (list last))
    (last . most) xs
    (tag . xs) (tup->list v)]))

; same, but overwrite first element
(defn vec-rot-with [x v]
  (in (list->tup (cons tag xs')
   [xs' (++ (tl xs) (list x))
    (tag . xs) (tup->list v)])))

; first vector element ('x')
(defn 1st-el [v] (element 2 v))
@

Alternatively, an index into the vector could be used.

<<Vectors>>=
(defn vec-size [v] (- (size v) 1))

; proper zero-based indexing
(defn vec-nth [n v] (element (+ n 2) v))

; overflow indexes that get too large
(defn vec-index [n v]
  (let (if (< 0 n') n' (+ size n'))
   [n' (rem n size)
    size (vec-size v)]))
@

Because trivial splits always cut volumes in exactly half, our BSP tree dimensions are restricted to powers of two.

<<Utilities>>=
; test for power of two
(defn 2^n?
  [n] (when (=< n #xff)) (2^n-byte? n)
  [n] (andalso (== 0 (band #xff n)) 
               (2^n? (bsr n 8))))

(defn 2^n-byte?
  [1]  'true [2]  'true [4]  'true [8]   'true
  [16] 'true [32] 'true [64] 'true [128] 'true
  [_] 'false)
@

<<Vectors>>=
(defn 2^n-vec? [v]
  (lists:all (fun 2^n? 1) (vec-contents v)))
@

Finally, the minimum usual operations. The size-apathetic arithmetic ones are slow, but can be optimized later as needed. (When there are benchmarks proving they're worth optimizing.) Pattern matching common (2, 3, 4d vectors) cases should be enough. Using macros to compile matches for arbitrary sizes would be fun, but probably unnecessary.

<<Vectors>>=
; construct a null vector of the same type as another
(defn null-vec [v] 
  (: erlang make_tuple (vec-size v) 0 
                       (list (tuple 1 (element 1 v))))

(defn unit-hypercube? [v]
  (== v (: erlang make_tuple (vec-size v) 1
                             (list (tuple 1 (element 1 v))))))

(defn :+ (va vb) 
  (in (make-vec tag els)
   [tag (element 1 va)
    els (lists:zipwith (fun erlang + 2) 
                       (vec-contents va) 
                       (vec-contents vb))]))
@


\section{Foundations}

<<Intro docs>>=
Trees are indexed by an N-dimensional vector, and can contain anything.
```erlang
-type tree(N,A)::{bsp,term(),term()} when N::integer(), A::any().
```
@

<<Exports>>=
(is_tree 1)
@

<<Functions>>=
(defn is_tree 
  [(tuple 'bsp size _data)] (2^n-vec? size)
  [_] 'false)
@

\subsection{Construction}

Let's start by constructing a tree. The minimal tree is a single homogenous volume, with power-of-two dimensions. Trees with identical dimensions are merged together to form larger trees, with merges happening sequentially through all the dimensions of the tree.

Most initial data representations are flat, and don't group together similar contents. Trees do: when constructing a tree out of flat data, we need to do lots of comparisons between branches, and merge branches into a single volume if they're both minimal and identical.

Since there are many flat data types, we'll make the constructor a higher order function. We recursively subdivide the tree into smaller ones, until they're 1x1x1 in size. Then we use the lookup function to find the value of the volume there, and move up the stack, doing comparisons and merging as we go.

<<Exports>>=
(new 2)
@

<<Building docs>>=
```erlang
-spec new(Size::vector(N), Lookup(vector(N))->A)->tree(N,A).
```
@

<<Utilities>>=
(defmacro :bsp ([size data] `(tuple 'bsp ,size ,data)))
@

<<Functions>>=
(defn new [size lup] 
  (if (2^n-vec? size)
    (:bsp size (build-new size (null-vec size) lup))
    (error 'badarg (list size lup))))
; where
  (defn build-new [size pos lup]
    (if (unit-hypercube? size)
      ; 1x1x1 sizes can be looked up
      (let [(volume (funcall lup pos))]
        (if (is_list volume)
          (error (tuple 'no_lists pos volume)))
        volume)
      ; larger ones must be split into two branches
      (in (if (minimal-identical-trees? left right)
            left ; merge
            (cons left right)) ; branch
       [left (build-new size' pos-left lup)
        right (build-new size' pos-right lup)
        ; cut the current axis in two
        size' (vec-rot-with (bsr (1st-el size) 1) size)
        ; position increased by an order of magnitude, with
        ; least significant bit indicating choice between
        ; left and right branches
        pos-left (vec-rot-with offset pos)
        pos-right (vec-rot-with (bor 1 offset) pos)
        offset (bsl (1st-el pos) 1)])))
  (defn minimal-identical-trees? [a b]
    (andalso (not (is_list a))
             (not (is_list b))
             (== a b)))
    
@

\subsection{Factoring}

Each cons cell represents a split on an axis. The axises are round robined. They are independent: so much so that an N dimensional tree can be factored into a J dimensional tree of K dimensional trees, where J+K=N.

<<Transforming docs>>=
Factor a tree into a lower-dimension tree of lower-dimension trees. Non-zero
vector elements mark dimensions to use in the top tree.
```erlang
-spec factor(vector(N), tree(N,A))->tree(J,tree(K,A)) where J+K=N.
```
@

<<Exports>>=
(factor 2)
@

<<Utilities>>=
(defn fold-dn [fold-fun acc0 tree] 'todo)
@

\section{Todo}

<<Viewing docs>>=
    todo
@
<<Querying docs>>=
    todo
@

\section{Index}
\nowebindex
\end{document}
